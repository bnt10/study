# 클로저 (Closure)

클로저를 이해하기 위해서는 먼저 어휘적 환경(Lexical Environment)의 개념을 이해하는 것이 중요합니다. JavaScript에서 어휘적 환경은 코드의 어휘적 구조에 기반하여 변수와 함수의 스코프를 결정합니다. 이러한 스코핑 규칙은 클로저가 어떻게 작동하는지를 이해하는 데 핵심적인 역할을 합니다.

### 어휘적 환경 (Lexical Environment)

어휘적 환경은 두 가지 주요 구성 요소를 갖습니다:

1. **환경 레코드(Environment Record)**: 코드에서 선언된 변수와 함수 선언을 저장하는 곳입니다.
2. **외부 어휘적 환경에 대한 참조(Outer Lexical Environment Reference)**: 이는 외부 어휘적 환경으로의 참조를 유지하며, 스코프 체인을 형성합니다. 이를 통해 함수는 외부 변수에 접근할 수 있습니다.



클로저는 함수와 그 함수가 선언된 어휘적 환경의 조합으로, 자신이 생성된 환경의 변수에 접근할 수 있으며, 이러한 변수들은 함수가 활성화되어 있지 않을 때에도 사라지지 않습니다. 클로저는 다음과 같은 특징을 가집니다:

- **접근 가능한 변수**: 클로저는 자신이 생성된 시점의 어휘적 환경에 있는 변수에 접근할 수 있습니다.
- **상태 유지**: 클로저는 데이터를 숨기고 유지하는 데 사용될 수 있으며, 외부 함수에서 내부 함수로 데이터를 전달하는 데 사용됩니다.

### TypeScript 예시

TypeScript에서 클로저를 구현하는 예시는 다음과 같습니다:

```typescript
function createCounter() {
  let count = 0; // 'createCounter'의 어휘적 환경에 속하는 변수
  return function() {
    count++;
    console.log(count);
  };
}

const counter = createCounter();
counter(); // 1
counter(); // 2
```

이 예시에서 `createCounter` 함수는 내부 함수를 반환하며, 이 내부 함수는 `createCounter`의 지역 변수 `count`에 접근합니다. 이 내부 함수는 클로저이며, `counter` 변수에 할당된 후에도 `createCounter`의 `count` 변수에 계속 접근할 수 있습니다.

 ### 사용 사례

1. **데이터 은닉 및 캡슐화**
   - 클로저를 사용하여 특정 데이터를 외부로부터 보호하고, 이를 통해 객체 지향 프로그래밍의 캡슐화 원칙을 모방할 수 있습니다.
   - 예: 모듈 패턴에서 클로저는 공개적으로 접근 가능한 메소드를 제공하면서도 내부 상태를 숨기는 데 사용됩니다.

2. **상태 유지**
   - 클로저는 외부 함수가 종료된 후에도 내부 함수가 외부 함수의 변수를 참조할 수 있게 해주어, 상태를 유지할 수 있게 합니다.
   - 예: 이터레이터나 제너레이터 구현에서 클로저는 현재 위치나 상태를 기억하는 데 사용됩니다.

3. **콜백 함수 및 고차 함수에서의 사용**
   - 클로저는 비동기 작업(예: AJAX 요청)이나 이벤트 리스너에서 초기 상태를 유지하는 데 사용됩니다.
   - 예: 클로저를 사용하여 비동기 작업의 결과에 따라 다른 행동을 하는 콜백 함수를 구현할 수 있습니다.

4. **함수 커링(Function Currying)**
   - 클로저는 함수의 일부 인자를 미리 설정하고, 나중에 나머지 인자를 받을 수 있는 커링된 버전의 함수를 생성하는 데 사용됩니다.
   - 예: 함수가 여러 인자를 받는 경우, 이 중 일부를 미리 "세팅"하여 새로운 함수를 생성할 수 있습니다.
   - 함수 커링(Function Currying)은 여러 인자를 받는 함수를 변환하여, 이 인자들을 단계적으로 받을 수 있는 함수로 만드는 기술입니다.
     이를 통해 함수의 일부 인자를 미리 "세팅"하고, 나머지 인자는 나중에 전달할 수 있습니다. 클로저는 이 과정에서 중요한 역할을 합니다, 왜냐하면 커링된 함수는 세팅된 인자들을 내부적으로 "기억"해야 하기 때문입니다.  

     ```typescript
      function curry(f: Function) {
        return function curried(...args: any[]) {
          if (args.length >= f.length) {
            return f.apply(this, args);
          } else {
            return function(...args2: any[]) {
              return curried.apply(this, args.concat(args2));
            }
          }
        };
      }
      
      // 예를 들어, 3개의 인자를 받는 간단한 함수
      function sum(a: number, b: number, c: number): number {
        return a + b + c;
      }
      
      // 'curry' 함수를 사용하여 'sum' 함수를 커링
      const curriedSum = curry(sum);
      
      // 이제 이 함수는 분할된 인자들로 호출될 수 있습니다.
      console.log(curriedSum(1)(2)(3)); // 6 - 각 숫자를 별도로 전달
      console.log(curriedSum(1, 2)(3)); // 6 - 처음 두 숫자를 한 번에, 세 번째 숫자는 별도로 전달
      ```
    이 예시에서 `curry` 함수는 일반 함수를 받아, 그 함수를 커링 버전으로 변환합니다.
    `sum` 함수는 세 개의 숫자를 더하는 간단한 함수입니다. `curry` 함수를 사용하여 `sum`을 커링하면, 이제 `sum` 함수는 분할된 인자들을 순차적으로 받을 수 있습니다.



6. **타이머 및 지연 실행**
   - 클로저는 설정된 시간이 지난 후 특정 코드를 실행하거나, 지연된 실행을 위한 타이머 기능에 사용됩니다.
   - 예: `setTimeout`이나 `setInterval`과 같은 함수에서 클로저는 필요한 변수와 상태를 유지하는 데 사용됩니다.

