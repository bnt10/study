# 서버 컴포넌트(Server Component)와 클라이언트 컴포넌트(Client Component)

`서버 컴포넌트`는 주로 정적인 내용을 렌더링하는데 사용됩니다. 
이 컴포넌트는 서버에서 렌더링되고, 결과적으로 HTML과 CSS만을 생성하며, 자바스크립트 실행 없이 클라이언트에 전달됩니다. 
이 방식은 초기 로딩 성능을 향상시키고, 클라이언트의 자바스크립트 실행 부하를 줄일 수 있습니다.

`클라이언트 컴포넌트`는 상호작용이 필요한 컴포넌트, 
예를 들어 상태 변경이 필요한 버튼이나 입력 필드 등에 사용됩니다. 
`클라이언트 컴포넌트`는 클라이언트 사이드에서만 렌더링되고, 자바스크립트를 통해 동작하므로 서버 컴포넌트보다 다룰 수 있는 기능이 풍부합니다.

`서버 컴포넌트`는 파일명에 `.server.js`를, `클라이언트 컴포넌트`는 `.client.js`를 확장자로 사용합니다. 
이외에도, 특정 컴포넌트를 클라이언트 컴포넌트로 만들기 위해 컴포넌트 파일의 최상단에 `'use client';`를 추가할 수 있습니다.

또한, 서버 컴포넌트와 클라이언트 컴포넌트는 서로 중첩될 수 있습니다. 
즉, 서버 컴포넌트 내부에 클라이언트 컴포넌트를 둘 수 있고, 그 반대도 가능합니다. 
이는 다양한 상황에서 성능을 최적화하고, 필요에 따라 동적인 기능을 제공할 수 있도록 해줍니다.

이들 컴포넌트의 선택 및 사용은 각 웹 페이지의 특성과 요구 사항에 따라 달라질 것입니다. 
주로 정적인 컨텐츠를 제공하는 페이지는 서버 컴포넌트를, 동적인 상호작용이 많은 페이지는 클라이언트 컴포넌트를 사용할 것입니다. 
이 두가지를 적절히 혼합하여 사용하면 웹 애플리케이션의 성능과 사용자 경험을 효과적으로 개선할 수 있습니다.

# 중첩된 서버 컴포넌트와 클라이언트 컴포넌트

Next.js 13 이상에서는 페이지를 서버 컴포넌트로 작성하고, 그 내부에 클라이언트 컴포넌트를 포함시키는 방식이 가능합니다.
예를 들어, 웹 페이지의 전체 레이아웃이나 메타데이터, 서버에서 직접 가져온 데이터 등은 서버 컴포넌트에서 처리하고, 사용자 입력을 처리하는 폼, 상태를 가진 버튼 
클라이언트 사이드에서 동적으로 업데이트되는 부분 등은 클라이언트 컴포넌트에서 처리하게 됩니다.

이렇게 구조화하면 서버와 클라이언트 각각의 장점을 최대한 활용할 수 있습니다. 
서버 컴포넌트를 통해 초기 페이지 로딩 성능을 향상시키고, 클라이언트 컴포넌트를 통해 동적인 상호작용을 구현할 수 있습니다.

이 구조는 Next.js의 경로 기반 라우팅과 함께 사용됩니다. 
즉, 파일 시스템 기반의 라우팅을 통해 각 페이지를 서버 컴포넌트로 작성하고, 해당 페이지 내에서 필요한 클라이언트 컴포넌트를 호출하게 됩니다.

다만, 기존에 사용하던 React 컴포넌트는 클라이언트 컴포넌트로 간주됩니다. 그래서 이 컴포넌트들은 useClient()나 .client.js 확장자 없이도 클라이언트 컴포넌트로 동작하게 됩니다. 
이에 유의하여 기존 코드를 이용하거나 새로운 컴포넌트를 작성하면 됩니다.

예를 들어, 간단한 페이지 뷰 카운터를 구현해보겠습니다.
먼저, 페이지 뷰 카운터를 위한 서버 컴포넌트를 만들겠습니다. 이 컴포넌트는 서버에서 페이지 뷰를 가져와 렌더링합니다. 파일명은 PageView.server.js로 해주세요.
```javascript
import fetchPageViews from '../lib/fetchPageViews'; // 임의의 페이지 뷰를 가져오는 함수라 가정합니다.

export default function PageView() {
  const pageViews = fetchPageViews();

  return (
    <div>
      <h1>Page Views: {pageViews}</h1>
      <IncrementButton /> {/* 클라이언트 컴포넌트를 사용하고 있습니다. */}
    </div>
  );
}
```

다음으로, 페이지 뷰를 증가시키는 버튼을 위한 클라이언트 컴포넌트를 만들어보겠습니다.
이 컴포넌트는 클라이언트에서 페이지 뷰를 증가시키는 상호작용을 처리합니다. 파일명은 IncrementButton.client.js로 해주세요.

```javascript
import { useState } from 'react';
import incrementPageViews from '../lib/incrementPageViews'; // 임의의 페이지 뷰를 증가시키는 함수라 가정합니다.

export default function IncrementButton() {
  const [loading, setLoading] = useState(false);

  const handleClick = async () => {
    setLoading(true);
    await incrementPageViews();
    setLoading(false);
  };

  return (
    <button onClick={handleClick} disabled={loading}>
      {loading ? 'Loading...' : 'Increment Page Views'}
    </button>
  );
}
```

위의 예제에서 PageView.server.js는 페이지 뷰 수를 렌더링하고
클라이언트 컴포넌트인 IncrementButton.client.js를 불러와서 페이지 뷰를 증가시키는 버튼을 렌더링합니다. 

IncrementButton.client.js는 클라이언트 사이드에서 페이지 뷰를 증가시키는 API를 호출하고, 버튼의 상태를 업데이트합니다.
이렇게 서버 컴포넌트와 클라이언트 컴포넌트를 조합하면 서버 사이드에서 필요한 데이터를 미리 불러올 수 있고, 클라이언트 사이드에서는 동적인 상호작용을 처리할 수 있습니다. 
