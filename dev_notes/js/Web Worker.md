# Web Worker

## **정의**:
   웹 워커(Web Worker)는 웹 애플리케이션에서 백그라운드 스레드를 생성하여 병렬 처리를 가능하게 하는 기술입니다. 메인 스레드(주로 UI를 처리하는 스레드)가 무거운 작업에 의해 블록되지 않도록 도와줍니다. 웹 워커는 메인 스레드와는 별도의 실행 컨텍스트에서 동작하며, 메인 스레드와는 메시지 기반으로 통신합니다.
   
   **React 컴포넌트 예시**:
   ```jsx
   import React, { useEffect, useState } from 'react';

   const MyComponent = () => {
     const [workerResult, setWorkerResult] = useState(null);

     useEffect(() => {
       const worker = new Worker('/worker.js');

       worker.onmessage = (e) => {
         setWorkerResult(e.data);
       };

       worker.postMessage('Start');

       return () => worker.terminate();
     }, []);

     return (
       <div>
         워커 결과: {workerResult}
       </div>
     );
   };

   export default MyComponent;
   ```

   **워커 스크립트 (`public/worker.js`)**:
   ```javascript
   onmessage = function(e) {
     let result = 0;
     for (let i = 0; i < 1000000; i++) {
       result += Math.sqrt(i);
     }
     postMessage(result);
   }
   ```
## **활용**:
   웹 워커는 CPU 집약적이거나 시간이 많이 걸리는 작업을 처리할 때 주로 사용됩니다. 예를 들어, 대량의 데이터를 처리하거나 복잡한 계산, 이미지 또는 비디오 처리, 파일 압축 등의 작업에서 유용합니다. 이러한 작업을 워커에서 수행함으로써 메인 스레드는 사용자 인터페이스와 상호작용을 계속할 수 있어, 웹 애플리케이션의 응답성이 향상됩니다.
   
## **장단점**:
   - **장점**:
     - **성능 향상**: 백그라운드에서 작업을 수행하여 메인 스레드의 부하를 줄이고, 애플리케이션의 반응 속도를 향상시킵니다.
     - **멀티스레딩**: 병렬 처리를 통해 멀티코어 프로세서의 이점을 활용할 수 있습니다.
     - **사용자 인터페이스 차단 방지**: 메인 스레드가 사용자 인터랙션과 UI 렌더링에 집중할 수 있습니다.
   - **단점**:
     - **메모리 사용**: 각 워커는 별도의 메모리 공간을 사용하기 때문에, 워커가 많을수록 메모리 사용량이 증가합니다.
     - **데이터 전송 오버헤드**: 메인 스레드와 워커 간의 데이터 전송에는 비용이 발생합니다.
     - **DOM 접근 불가**: 워커는 DOM에 직접 접근할 수 없습니다.

## **주의할점**:
   - **데이터 전송 방식 이해**: 메인 스레드와 워커 간의 데이터 전송은 복사를 통해 이루어집니다. 따라서 큰 데이터를 전송할 때는 성능에 영향을 줄 수 있습니다.
   - **DOM 조작 불가**: 워커는 DOM을 직접 조작할 수 없으므로, UI 관련 작업은 메인 스레드에서 처리해야 합니다.
   - **브라우저 호환성**: 모든 브라우저에서 웹 워커를 지원하지 않을 수 있으므로, 호환성을 고려해야 합니다.
   - **적절한 작업 분할**: 워커를 효율적으로 사용하기 위해서는 작업을 적절히 나누고 분배하는 것이 중요합니다.
   - **리소스 관리**: 사용하지 않는 워커는 적절히 종료하여 리소스를 해제해야 합니다.


